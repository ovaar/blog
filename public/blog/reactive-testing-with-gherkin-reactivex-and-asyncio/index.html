<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Ovaar"><meta name=description content="Software Engineering blog"><title>Reactive testing with Gherkin, ReactiveX and asyncio - Ovaar - Software engineering blog</title><link rel=stylesheet href=/css/stylesheet.min.css><link href rel=feed type=application/rss+xml title="Ovaar - Software engineering blog"><script src=/theme-toggle.min.js></script></head><body><header><nav><a href=https://ovaar.github.io/>Ovaar - Software engineering blog</a><ul><li><a href=https://ovaar.github.io/>Home</a></li><li><a href=https://ovaar.github.io/blog/>Blog</a></li><li><a href=/tags>Tags</a></li><li><button id=theme-toggle class=theme-toggle aria-label="Toggle theme mode">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
<svg class="dark-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></button></li></ul></nav><h1>Reactive testing with Gherkin, ReactiveX and asyncio</h1><p><small>published on Mon, 14 Sep 2020</small></p></header><hr><main><div class=tags><a href=/tags/python class=tag>#python</a></div><article class=content><p>Have you ever written integration test with asynchronous behavior? I have, and it has always been a struggle&mldr; CI/CD pipelines which regularly fail because of some timeout. Then, &ldquo;a wild project manager appears!&rdquo;, and starts asking questions why investigating takes so long&mldr;</p><blockquote><p>Solution: The timeout is increased to quickly solve the issue, when usually the failure is caused by regression.</p></blockquote><p>There must be some more elegant way to assert or await asynchronous calls in Behavior Driven Development (BDD) steps.</p><p>I am excited, enjoy what&rsquo;s coming next! I developed a more comfortable way to add asynchronous assertions in integration tests without adding <code>time.sleep(n)</code>.</p><p>TLDR;
This post is about practical use of combining RxPy, pytest, Gherkin, asyncio with automated testing using Python and not an introduction of the previously described libraries. Regardless of using Python I believe this test strategy can be reused with any other programming language supported by ReactiveX. The application sources can be found on <a href=https://github.com/ovaar/reactive-testing>Github</a>.</p><p>Let&rsquo;s break it down, but before I do I would like to set the scene for the demo application with the following use case.</p><blockquote><p>Use case: I have a central lighting system where lights can connect to and as a user I want to be able to turn on and off the lights.</p></blockquote><p>To only focus on the testing part, we will abstract the lighting hardware using a simulator and assume the lights are able to communicate via the MQTT protocol. Let&rsquo;s begin with looking at how the Gherkin test Feature is described which will be used in order to execute the test.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gherkin data-lang=gherkin><span class=line><span class=cl><span class=c># lighting\integration_tests\tests\features\lighting.feature</span><span class=nf>
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>Feature:</span><span class=nf> The lights must be able to be turned on and off
</span></span></span><span class=line><span class=cl><span class=nf>
</span></span></span><span class=line><span class=cl><span class=nf>    </span><span class=k>Scenario:</span><span class=nf> The lights are controlled
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>        Given </span><span class=nf>I have a light with the id </span><span class=nv>&lt;light_id&gt;</span><span class=nf>
</span></span></span><span class=line><span class=cl><span class=nf>        </span><span class=k>And </span><span class=nf>the light </span><span class=nv>&lt;light_id&gt;</span><span class=nf> is turned </span><span class=nv>&lt;light_begin_state&gt;</span><span class=nf>
</span></span></span><span class=line><span class=cl><span class=nf>        </span><span class=k>And </span><span class=nf>I expect the final state of light </span><span class=nv>&lt;light_id&gt;</span><span class=nf> to be </span><span class=nv>&lt;light_final_state&gt;</span><span class=nf>
</span></span></span><span class=line><span class=cl><span class=nf>        </span><span class=k>When </span><span class=nf>the lights are connected
</span></span></span><span class=line><span class=cl><span class=nf>        </span><span class=k>Then </span><span class=nf>I use </span><span class=nv>&lt;light_function&gt;</span><span class=nf> to control the lights
</span></span></span><span class=line><span class=cl><span class=nf>        </span><span class=k>And </span><span class=nf>I await the result
</span></span></span><span class=line><span class=cl><span class=nf>
</span></span></span><span class=line><span class=cl><span class=nf>        </span><span class=k>Examples:</span><span class=nf> Vertical</span><span class=k>
</span></span></span><span class=line><span class=cl><span class=k>            |</span><span class=nv> light_id</span><span class=k>          |</span><span class=nv> lightbulb-1</span><span class=k> |</span><span class=nv> lightbulb-2</span><span class=k> |</span><span class=nf>
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>            |</span><span class=s> light_begin_state</span><span class=k> |</span><span class=s> OFF</span><span class=k>         |</span><span class=s> ON</span><span class=k>          |</span><span class=nf>
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>            |</span><span class=s> light_function</span><span class=k>    |</span><span class=s> on</span><span class=k>          |</span><span class=s> off</span><span class=k>         |</span><span class=nf>
</span></span></span><span class=line><span class=cl><span class=nf></span><span class=k>            |</span><span class=s> light_final_state</span><span class=k> |</span><span class=s> ON</span><span class=k>          |</span><span class=s> OFF</span><span class=k>         |
</span></span></span></code></pre></div><p>The test consists of three stage. In some way it like a Unit Test it uses Arrange / Act / Assert (AAA). In the first stage an object is build containing the initial stage for the simulator as well as setting up the the ReactiveX Observables in order to receive new states via a Mqtt Client. The ReactiveX Observables you could compare to adding a <code>spy</code> to a method in order to check if it was called. This must be done before executing the test so that we will not miss any events.</p><p>The second stage adds Lightbulb Simulators to the <code>TestContext</code> and connects them to the MQTT broker. The simulator publishes the topic <code>lights/connect/$lightId</code> to register itself with the <code>core</code> module. Then the connected lights can be controlled by sending an MQTT message to topic <code>lights/function/on</code> or <code>lights/function/off</code>. The <code>core</code> will publish an individual topic for each simulated Lightbulb. Below you see the <code>Lightbulb</code> data holder class. In order to understand the last BDD step <code>And I await the result</code> I have to first explain about how <code>rx.subject</code> works.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># lighting\integration_tests\tests\data.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>Dict</span><span class=p>,</span> <span class=n>Optional</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>rx.subject</span> <span class=k>as</span> <span class=nn>RxSubject</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Lightbulb</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>uuid</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>state</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>light_state</span><span class=p>:</span> <span class=n>RxSubject</span><span class=o>.</span><span class=n>Subject</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>uuid</span><span class=p>:</span> <span class=nb>str</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>uuid</span> <span class=o>=</span> <span class=n>uuid</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>light_state</span> <span class=o>=</span> <span class=n>RxSubject</span><span class=o>.</span><span class=n>Subject</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>complete</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>light_state</span><span class=o>.</span><span class=n>on_completed</span><span class=p>()</span>
</span></span></code></pre></div><p>The class <code>rx.Subject</code> inherits from <code>rx.core.Observable</code> and <code>rx.core.Observer</code>. The class <code>rx.Subject</code> allows you to push data into the Rx Operators using the <code>rx.core.Observable</code> interface. When a new state is received via the topic: <code>lights/{lightbulbId/state</code>, then the <code>light_state.on_next(...)</code> is called which pipes the data to the <code>rx.operators</code>. ReactiveX operators are basically predicate functions which will evaluate the observable state with every element added to the sequence. I use <a href=http://reactivex.io/documentation/operators/takewhile.html>rx.operators.take_while</a> to evaluate if the state of the lightbulb equals the expected <code>light_final_state</code>. The <code>take_while</code> Operator will automatically call on_complete if predicate function returns <code>False</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># lighting\integration_tests\tests\steps\lights.py</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>rx.operators</span> <span class=k>as</span> <span class=nn>RxOp</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>rx</span> <span class=kn>import</span> <span class=n>Observable</span> <span class=k>as</span> <span class=n>RxObservable</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>rx.scheduler.eventloop</span> <span class=kn>import</span> <span class=n>AsyncIOScheduler</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@given</span><span class=p>(</span><span class=s1>&#39;I expect the final state of light &lt;light_id&gt; to be &lt;light_final_state&gt;&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>light_state_equals</span><span class=p>(</span><span class=n>light_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=n>light_final_state</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=n>test_context</span><span class=p>:</span> <span class=n>Data</span><span class=o>.</span><span class=n>TestContext</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=n>loop</span><span class=p>:</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>AbstractEventLoop</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=n>awaitables</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>RxObservable</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>light_id</span><span class=p>,</span> <span class=nb>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>light_final_state</span><span class=p>,</span> <span class=nb>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>take_while_state</span><span class=p>(</span><span class=n>payload</span><span class=p>:</span> <span class=n>Structs</span><span class=o>.</span><span class=n>s_lights_state</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>payload</span><span class=o>.</span><span class=n>newState</span> <span class=o>!=</span> <span class=n>light_final_state</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>timeout_sec</span> <span class=o>=</span> <span class=mf>10.0</span>
</span></span><span class=line><span class=cl>    <span class=c1># Get the lightbulb by id from the test context fixture</span>
</span></span><span class=line><span class=cl>    <span class=n>lightbulb</span><span class=p>:</span> <span class=n>Data</span><span class=o>.</span><span class=n>Lightbulb</span> <span class=o>=</span> <span class=n>test_context</span><span class=o>.</span><span class=n>lightbulbs</span><span class=p>[</span><span class=n>light_id</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1># Rx .pipe returns a new observable</span>
</span></span><span class=line><span class=cl>    <span class=n>observable</span><span class=p>:</span> <span class=n>RxObservable</span> <span class=o>=</span> <span class=n>lightbulb</span><span class=o>.</span><span class=n>light_state</span><span class=o>.</span><span class=n>pipe</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    	<span class=c1># Add a default timeout for the test to fail if no data is received</span>
</span></span><span class=line><span class=cl>        <span class=n>RxOp</span><span class=o>.</span><span class=n>timeout</span><span class=p>(</span><span class=n>timeout_sec</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=c1># Add the AsyncIOScheduler to be able to asynchronously re-evaluate</span>
</span></span><span class=line><span class=cl>    	<span class=c1># the state of the RxObserable for changes</span>
</span></span><span class=line><span class=cl>        <span class=n>RxOp</span><span class=o>.</span><span class=n>observe_on</span><span class=p>(</span><span class=n>scheduler</span><span class=o>=</span><span class=n>AsyncIOScheduler</span><span class=p>(</span><span class=n>loop</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>        <span class=c1># Add data to the RxObservable sequence while the predicate function</span>
</span></span><span class=line><span class=cl>    	<span class=c1># returns True. If it returns False the RxObservable is automatically</span>
</span></span><span class=line><span class=cl>    	<span class=c1># completed and it includes the last result.</span>
</span></span><span class=line><span class=cl>        <span class=n>RxOp</span><span class=o>.</span><span class=n>take_while</span><span class=p>(</span><span class=n>take_while_state</span><span class=p>,</span> <span class=n>inclusive</span><span class=o>=</span><span class=kc>True</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>observable</span><span class=o>.</span><span class=n>subscribe</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>on_next</span><span class=o>=</span><span class=k>lambda</span> <span class=n>i</span><span class=p>:</span> <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;on_next: </span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>on_error</span><span class=o>=</span><span class=k>lambda</span> <span class=n>e</span><span class=p>:</span> <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;on_error: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>on_completed</span><span class=o>=</span><span class=k>lambda</span><span class=p>:</span> <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;on_completed&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>scheduler</span><span class=o>=</span><span class=n>AsyncIOScheduler</span><span class=p>(</span><span class=n>loop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>awaitables</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>observable</span><span class=p>)</span>
</span></span></code></pre></div><p>Finally, the last step <code>And I await the result</code> from the file <code>lighting.feature</code> uses Asyncio to asynchronously await the ReactiveX Observables which were added to the <code>awaitables</code> list. The <a href=https://docs.python.org/3/library/asyncio-task.html#asyncio.gather>asyncio.gather</a> function will await for all results to be completed. Wrapping the <code>asyncio.gather</code> in a <code>main</code> function and executing it on the asyncio event loop using <code>loop.run_until_complete(main())</code> will block until all have been completed successfully or an exception is thrown.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># lighting\integration_tests\tests\steps\lights.py</span>
</span></span><span class=line><span class=cl><span class=nd>@then</span><span class=p>(</span><span class=s1>&#39;I await the result&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>await_the_result</span><span class=p>(</span><span class=n>awaitables</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>RxObservable</span><span class=p>],</span> <span class=n>loop</span><span class=p>:</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>AbstractEventLoop</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>awaitables</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Nothing to await, continuing... &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;Awaiting tasks, count=</span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>awaitables</span><span class=p>)</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=o>*</span><span class=n>awaitables</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;start: run_until_complete&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>loop</span><span class=o>.</span><span class=n>run_until_complete</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>awaitables</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>awaitables</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span>
</span></span></code></pre></div><p>That is all! I hope I inspired you or gave you some insight in how to approach asynchronous assertions in testing software. For the ones who are curious about the test output, have a look below.</p><pre tabindex=0><code>lighting-integration-tests_1  | ============================= test session starts ==============================
lighting-integration-tests_1  | platform linux -- Python 3.8.2, pytest-6.0.1, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3
lighting-integration-tests_1  | cachedir: .pytest_cache
lighting-integration-tests_1  | rootdir: /lighting/integration_tests
lighting-integration-tests_1  | plugins: bdd-3.3.0
lighting-integration-tests_1  | collecting ... collected 2 items
lighting-integration-tests_1  |
lighting-integration-tests_1  | tests/main.py::test_turn_on_the_lights[lightbulb-1-OFF-on-ON] pytest::before &lt;Function test_turn_on_the_lights[lightbulb-1-OFF-on-ON]&gt;
lighting-integration-tests_1  | Scenario::before: The lights are controlled
lighting-integration-tests_1  | create: loop
lighting-integration-tests_1  | create: awaitables
lighting-integration-tests_1  | PASSED Step: I have a light with the id &lt;light_id&gt;
lighting-integration-tests_1  | PASSED Step: the light &lt;light_id&gt; is turned &lt;light_begin_state&gt;ReactiveListener::on_connect Connected with result code 0
lighting-integration-tests_1  |
lighting-integration-tests_1  | PASSED Step: I expect the final state of light &lt;light_id&gt; to be &lt;light_final_state&gt;
lighting-integration-tests_1  | create: simulator
lighting-integration-tests_1  | LightbulbSimulator::connect_as lightbulb-1 to localhost:1883
lighting-integration-tests_1  | LightbulbSimulator::on_connect Lightbulb=lightbulb-1 connected
lighting-integration-tests_1  | LightbulbSimulator::on_message topic=lights/lightbulb-1/state/get payload=b&#39;&#39;
lighting-integration-tests_1  | LightbulbSimulator::on_message public topic=lights/lightbulb-1/state payload=s_lights_state(newState=&#39;OFF&#39;)
lighting-integration-tests_1  | ReactiveListener::on_message topic=lights/lightbulb-1/state payload=b&#39;{&#34;newState&#34;: &#34;OFF&#34;}&#39;
lighting-integration-tests_1  | on_next: s_lights_state(newState=&#39;OFF&#39;)
lighting-integration-tests_1  | PASSED Step: the lights are connected
lighting-integration-tests_1  | PASSED Step: I use &lt;light_function&gt; to control the lights
lighting-integration-tests_1  | Awaiting tasks, count=1
lighting-integration-tests_1  | start: run_until_complete
lighting-integration-tests_1  | LightbulbSimulator::on_message topic=lights/lightbulb-1/function/on payload=b&#39;&#39;
lighting-integration-tests_1  | LightbulbSimulator::on_message public topic=lights/lightbulb-1/state payload=s_lights_state(newState=&#39;ON&#39;)
lighting-integration-tests_1  | ReactiveListener::on_message topic=lights/lightbulb-1/state payload=b&#39;{&#34;newState&#34;: &#34;ON&#34;}&#39;
lighting-integration-tests_1  | on_next: s_lights_state(newState=&#39;ON&#39;)
lighting-integration-tests_1  | on_completed
lighting-integration-tests_1  | PASSED Step: I await the result
lighting-integration-tests_1  | PASSEDpytest::after &lt;Function test_turn_on_the_lights[lightbulb-1-OFF-on-ON]&gt;
lighting-integration-tests_1  | after: awaitables
lighting-integration-tests_1  |
lighting-integration-tests_1  | tests/main.py::test_turn_on_the_lights[lightbulb-2-ON-off-OFF] pytest::before &lt;Function test_turn_on_the_lights[lightbulb-2-ON-off-OFF]&gt;
lighting-integration-tests_1  | Scenario::before: The lights are controlled
lighting-integration-tests_1  | create: awaitables
lighting-integration-tests_1  | PASSED Step: I have a light with the id &lt;light_id&gt;
lighting-integration-tests_1  | PASSED Step: the light &lt;light_id&gt; is turned &lt;light_begin_state&gt;
lighting-integration-tests_1  | PASSED Step: I expect the final state of light &lt;light_id&gt; to be &lt;light_final_state&gt;
lighting-integration-tests_1  | create: simulator
lighting-integration-tests_1  | LightbulbSimulator::connect_as lightbulb-2 to localhost:1883
lighting-integration-tests_1  | LightbulbSimulator::on_connect Lightbulb=lightbulb-2 connected
lighting-integration-tests_1  | LightbulbSimulator::on_message topic=lights/lightbulb-2/state/get payload=b&#39;&#39;
lighting-integration-tests_1  | LightbulbSimulator::on_message public topic=lights/lightbulb-2/state payload=s_lights_state(newState=&#39;ON&#39;)
lighting-integration-tests_1  | ReactiveListener::on_message topic=lights/lightbulb-2/state payload=b&#39;{&#34;newState&#34;: &#34;ON&#34;}&#39;
lighting-integration-tests_1  | on_next: s_lights_state(newState=&#39;ON&#39;)
lighting-integration-tests_1  | PASSED Step: the lights are connected
lighting-integration-tests_1  | PASSED Step: I use &lt;light_function&gt; to control the lights
lighting-integration-tests_1  | Awaiting tasks, count=1
lighting-integration-tests_1  | start: run_until_complete
lighting-integration-tests_1  | LightbulbSimulator::on_message topic=lights/lightbulb-2/function/off payload=b&#39;&#39;
lighting-integration-tests_1  | LightbulbSimulator::on_message public topic=lights/lightbulb-2/state payload=s_lights_state(newState=&#39;OFF&#39;)
lighting-integration-tests_1  | ReactiveListener::on_message topic=lights/lightbulb-2/state payload=b&#39;{&#34;newState&#34;: &#34;OFF&#34;}&#39;
lighting-integration-tests_1  | on_next: s_lights_state(newState=&#39;OFF&#39;)
lighting-integration-tests_1  | on_completed
lighting-integration-tests_1  | PASSED Step: I await the result
lighting-integration-tests_1  | PASSEDpytest::after &lt;Function test_turn_on_the_lights[lightbulb-2-ON-off-OFF]&gt;
lighting-integration-tests_1  | after: awaitables
lighting-integration-tests_1  | exit: loop
lighting-integration-tests_1  |
lighting-integration-tests_1  |
lighting-integration-tests_1  | ============================== 2 passed in 22.08s ==============================
reactive-testing_lighting-integration-tests_1 exited with code 0
</code></pre></article></main><footer><footer><hr><div class=footer-content><div class=footer-info><p><small>Copyright &#169; 2020 Ovaar. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</small></p><p><small>created with <a href=https://gohugo.io>Hugo</a>,
<a href=https://github.com/andybrewer/mvp>mvp.css</a>.</small></p></div><div class=footer-social><div class=social><a href=https://github.com/ovaar target=_blank rel="noopener noreferrer" aria-label="github profile"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://www.linkedin.com/in/thomas-reynders-6bb57057/ target=_blank rel="noopener noreferrer" aria-label="linkedin profile"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></div></div></div></footer></footer></body></html>